### 参考文档：
#### （1）三次握手、四次挥手
https://www.bilibili.com/video/BV1bi4y1x7m5from=search&seid=16657988637693213954
#### （2）IP地址分类
https://blog.csdn.net/m0_37732829/article/details/94717850
#### （3）IP地址子网划分
https://kernel.blog.csdn.net/article/details/50989257?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param
#### （4）综合面试
https://blog.csdn.net/weixin_41910694/article/details/91960815
https://zhuanlan.zhihu.com/p/24001696
https://zhuanlan.zhihu.com/p/237948931
https://zhuanlan.zhihu.com/p/90876172

### TCP/IP协议
#### （1）应用层
#### （2）传输层
#### （3）网络层
#### （4）数据链路层
#### （5）物理层

## 一、TCP、UDP
### 1.TCP三次握手
三次握手最主要的目的是双方确认自己与对方的发送与接收是正常的。
#### （1）第一次握手：
过程：客户端向服务器发送连接请求，发起一个新连接SYN位为1，随机生成一个seq序号J
结果：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常

#### （2）第二次握手：
过程：服务器向客户端发送报文，确认标志位ACK为1，确认序号ack = J+1；发起一个新连接SYN为1，随机生成一个seq序号k
结果：客户端确认了自己发送、接收正常，对方发送、接收正常；服务器确认了对方发送正常，自己接收正常

#### （3）第三次握手：
过程：客户端向服务器发送报文，确认标志位ACK为1，确认序号ack = k + 1
结果：客户端确认了自己发送、接收正常，对方发送、接收正常；服务器确认了自己发送、接收正常，对方发送、接收正常

#### 问题：为什么不是二次握手
主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
如果采用的是三次握手，就算是失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### 2.TCP四次挥手
由于TCP连接时全双工的，因此每个方向都必须要单独进行关闭
#### （1）第一次挥手：
过程：客户端向服务器发送数据，断开连接标志位FIN为1，seq为x（x不是随机的）
#### （2）第二次挥手：
过程：服务器发送数据给客户端，确认标志位ACK位为1，确认序号ack = x + 1
#### （3）第三次挥手：
过程：服务器向客户端发送数据，断开连接标志位FIN为1，seq为y（y不是随机的）
#### （4）第四次挥手：
过程：客户端向服务器发送数据，确认标志位ACK位为1，确认序号ack = y + 1

#### 问题：为什么客户端最后发送数据库后，还要等待2MSL（MSL是报文最长生存时间）？
（1）让4次握手的关闭流程更加可靠。尽量保证服务器端能够收到自己发送的FIN的ACK。
（2）让此次TCP连接的报文在网络中消失。

### 3.TCP与UDP的区别
#### （1）TCP是面向连接，UDP是无连接的。
#### （2）TCP是可靠的，UDP是不可靠的。
#### （3）TCP是一对一通信，UDP支持任意多方通信。
#### （4）TCP面向字节流，UDP面向报文。

## 二、IP
### 1.IP地址分类
#### （1）A类地址
1个字节（8位）网络地址+3个字节（24位）主机号；以0开头；范围1.0.0.0到127.255.255.255；
127.0.0.1表示本机地址；默认子网掩码255.0.0.0

#### （2）B类地址
2个字节（16位）网络地址+2个字节（16位）主机号；以10开头；范围128.0.0.0到191.255.255.255；
128.0.0.0和191.255.0.0位保留地址；默认子网掩码255.255.0.0

#### （3）C类地址
3个字节（24位）网络地址+1个字节（8位）主机号；以110开头；范围192.0.0.0到223.255.255.255；
192.0.0.0和223.255.255.0位保留地址；默认子网掩码255.255.255.0

#### （4）D类地址
以1110开头；用于多点广播；

#### （5）E类地址
以11110开头；保留使用；

### 2.子网划分
（1）根据IP地址和掩码求网络号：IP地址和子网掩码进行与运算，结果是网络地址
```
举例：一个主机的IP地址是202.112.14.137，掩码是255.255.255.224，要求计算这个主机所在的网络地址？
广播地址？主机数？

（1）网络地址
IP地址转2进制：11001010 01110000 00001110 10001001
掩码转为2进制：11111111 11111111 11111111 11100000（网络号有27位，主机号有5位）
---------结果：11001010 01110000 00001110 10000000
即：202.112.14.128

（2）广播地址
广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159

（3）主机数
主机号有5位，那么这个地址中，就只能有2^5−2=30个主机
因为其中全0作为网络地址，全1作为广播地址
```

（2）ip段/数字：数字表示网络号的位数，也就是子网掩码中前多少位为1
```
举例1：129.168.1.1 /24 
这个24就是说网络号是24位
也就是说子网掩码是：11111111 11111111 11111111 00000000
即：255.255.255.0

举例2：172.16.10.33/27
这里27就是说网络号是27位
也就是说子网掩码是：11111111 11111111 11111111 11100000
即：255.255.255.224
```

### 3.ARP协议
#### 通过IP地址来获取MAC地址。
#### ARP工作过程：
（1）首先检查主机的ARP缓存表，如果有，那么直接使用。
（2）如果没有，就广播一个ARP请求数据包（包括源主机的IP地址、硬件地址、以及目的主机的IP地址），查询此目的主机对应的MAC地址。
（3）其它主机收到ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；
（4）如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果有了就覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己的MAC地址；
（5）源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。

### 三、HTTP 
#### 1.从输入网址到显示网页的过程
（1）使用DNS，找到域名对应的IP地址
（2）向服务器请求建立链接，发起三次握手
（3）链接建立后，向服务器发送HTTP请求；
（4）服务器接收到请求后进行处理，并将处理的结果返回给浏览器；
（5）浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

#### 2.状态码
##### （1）1×× : 请求处理中，请求已被接受，正在处理
##### （2）2×× : 请求成功，请求被成功处理
##### 200 OK
##### （3）3×× : 重定向，要完成请求必须进行进一步处理
##### 301 : 永久重定向（表示请求的资源被分配了新的URL，之后应使用更改的URL；）
##### 302 ：暂时重定向（表示请求的资源被分配了新的URL，希望本次访问使用新的URL；）
##### 304 ： 已缓存（表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；）
##### （4）4×× : 客户端错误，请求不合法
##### 400：语法错误
##### 403：服务器拒绝请求
##### 404：页面不存在
##### （5）5×× : 服务器端错误，服务器不能处理合法请求
##### 500 ：内部错误
##### 503 ： 服务不可用

#### 3.端口对应的服务
（1）20/21：FTP
（2）22：SSH
（3）53：DNS
（4）80：HTTP
（5）443：HTTPS

#### 4.DNS工作原理
##### 第一步：
客户机提出域名解析请求，并将该请求发送给本地的域名服务器。
##### 第二步：
当本地的域名服务器收到请求后，就先查询本地的缓存，如果有该纪录项，则本地的域名服务器就直接把查询的结果返回。
##### 第三步：
如果没有，则本地域名服务器就直接把请求发给根域名服务器，然后根域名服务器再返回给本地域名服务器一个所查询域(根的子域) 的主域名服务器的地址。
##### 第四步：
本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自己的缓存，如果没有该纪录，则返回相关的下级的域名服务器的地址。
##### 第五步：
重复第四步，直到找到正确的纪录。
##### 第六步：
本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时还将结果返回给客户机。
