一、Qt
1.元对象系统（元对象系统提供）
2.信号槽（信号槽连接的3种方式，第五个参数，信号槽和线程一起使用）
3.多线程（创建线程的2种方式，线程同步的5种方式，防止界面冻结的2种方式）
4.事件系统（自定义事件处理函数3种方式）
5.QSS
6.qmake
7.Qt下TCP通信过程
8.Qt下UDP通信过程
9.国际化



二、Qt
1.Qt提供了几种同步方式
2.Qt中，说一下创建线程方式
3.信号槽机制
4.设计模式了解多少？写个单例模式
5.信号槽连接有几种方式？直接连接是怎么执行的？
6.信号槽第五个参数：
7. qt中QObject类是做什么的，有哪些功能?
8.https://blog.csdn.net/xpg4321/article/details/101278293
9.

七、程序发布
1.程序打包说一下。


1.qt中都用到了哪些设计模式

1.线程和进程
14.信号槽的实现原理
9.信号槽优缺点

### 1.线程和进程
#### （1）进程是资源分配的独立单位；线程是资源调度的独立单位
#### （2）一个进程由多个线程组成；
#### （3）进程之间切换开销大；线程之间切换的开销小

### 2.线程同步和互斥
暂时只看Qt的线程同步



### 9.信号槽优缺点
#### 优点：
（1）低耦合：发送方不用管接收方是谁，只需要发送信号即可。同理，接收方也不用知道发送方是谁，只要信号到了就可以执行槽函数。
（2）类型安全：信号的参数类型和个数与接收方的一致。
#### 缺点：
（1）效率低：需要找接受信号的对象。


### 22.插件管理器
https://blog.csdn.net/kenfan1647/category_9967854.html

### 23.插件之间通信
https://blog.csdn.net/kenfan1647/category_9967854.html



#### 1.事件循环
Qt的主事件循环能够从事件队列中获取本地窗口系统事件，然后判断事件类型，并将事件分发给特定的接收对象。
主事件循环通过调用QCoreApplication::exec()启动，随着QCoreApplication::exit()结束，本地的事件循环可用利用QEventLoop构建。

#### 2.多线程
第一种方法:

创建一个类从QThread类派生
在子线程类中重写 run 函数, 将处理操作写入该函数中
在主线程中创建子线程对象, 启动子线程, 调用start()函数
第二种方法:
将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数
在主线程中创建一QThread类对象
在主线程中创建一个业务类对象
将业务类对象移动到子线程中
在主线程中启动子线程
通过信号槽的方式, 执行业务类中的业务处理函数
多线程使用注意事项:
业务对象, 构造的时候不能指定父对象
子线程中不能处理ui窗口(ui相关的类)
子线程中只能处理一些数据相关的操作, 不能涉及窗口

#### 3.多线程同步
1.临界区被初始化后，当程序进入临界区后便拥有临界区的所有权，其余线程无权进入只能等对方释放临界区之后，方可进入临界区拥有其所有权再对临界区进行操作临界区为依次访问，不能实现其中一个线程一释放临界区就会被另一个线程访问临界区！不能实现实时监听;
2.事件对象是指用户在程序中使用内核对象的有无信号状态实现线程的同步临界区被初始化后一旦事件对象被设置为有信号 立刻会被其余线程访问！能实现实时监听
3.互斥对象还可以在进程间使用，在实现线程同步时包含一个线程ID和一个计数器，
线程ID表示拥有互斥对象的线程，计数器表示该互斥对象被同一线程所使用次数
一旦互斥对象被释放 立刻会被其它正在等待的线程访问！能实现实时监听;

#### 4.什么是智能指针？有几种?分别是什么？
答:一般是指把指针封装到一个类中,这个类中还封装了一个计数器,
对指针的复制等操作将导致该计数器加1,对指针delete会减1,直到为0,
指针为NULL。
智能指针有:
shared_ptr、weak_ptr、unique_ptr和auto_ptr(c++11摒弃);
分别有：
1.auto_ptr定一对象可以将new到的地址赋给这一对象,当智能指针过期时
析构函数会调用delete函数,对象被销毁,由此内存可以自动被释放;
2.shared_ptr允许多个指针指向同一个对象,每多一个指针指向，
计数就会加1,释放的时候,当值减为0即最后一个指针过期才会delete函数11
3.unique_ptr唯一的，只能一个指针指向一个对象。
4.weak_ptr为配合shared_ptr而引入的用于协助shared_ptr工作.

#### 5.qt信号槽是什么？
答:信号槽实际就是观察者模式,当某个事件发生之后,它就会发出一个信号(signal),
这个信号类似广播, 想要处理的信号和自己的一个函数(槽函数(slot))绑定处理这个信号
当信号发出时,被链接的槽函数会自动被回调;
信号和槽是qt特有的信息传回机制,是QT设计程序的重要基础,它可以让互不相干扰的对象建立一种联系;
槽本质是类的成员函数,其参数可以是任意类型。
和函数唯一区别是：槽可以与信号连接在一起,每当和槽连接的信号被发射的时候,就会调用这个槽。
优缺点：
a QT信号槽机制的引用精简了程序员的代码量;
b QT的信号可以对应多个槽（但他们的调用顺序是随机），也可以多个槽映射一个信号;
c QT的信号槽的建立和解除绑定十分自由;
d信号槽同真正的回调函数比起来时间的耗损还是很大的，所有在嵌入式实时系统中应当慎用;
e信号槽的参数限定很多例如不能携带模板类参数，不能出现宏定义等等;

#### 6.信号槽的四种写法和五种连接方式？
connect(信号发出者，信号，信号接收者，槽，连接方式(隐藏默认自动连接))//五个参数
四种写法：
1.用宏：
connect(this,SIGNAL(clicked()),this,SLOT(colse())); //连接方式(隐藏默认自动连接))
2.用函数指针： connect(this,&mainwindow::my_signal,this,&mainwindow::my_slot);
3.用重载函数指针Qoverload
connect(this,Qoverload<参数>::of(&mainwindow::my_signal),this,Qoverload<参数>::of(&mainwindow::my_slot));
4.lambda表达式(匿名函数) 匿名函数代替槽
connect(this,&mainwindow::my_signal,this,[=]{qDebug()<<100;});
连接方式：自动连接(默认连接方式)
直接连接(用于单线程,自动匹配)
队列(用于多线程也可用于单线程,自动匹配)
阻塞队列(跨线程,多线程)
唯一连接(跨线程,多线程)

#### 7.Lambda表达式
答：lambda表达式主要分五部分:[函数对象参数]、(操作符重载函数参数)、mutable或 声明、->返回值类型、{函数体} [捕获列表] (参数列表) 函数选项 -> 返回值类型 {函数体}
[&]:以引用的方式捕获外部的所有变量，如果在函数体内改变外部变量值，外部变量值就会随之改变；
　　[=]:以值的方式捕获外部的所有变量，如果在函数体内改变“外部变量值”，外部变量值不会改变；

#### 8.q、d指针干什么用的？为了解决什么问题？
答：q子类获取父类私有成员指针
d在父类获取子类私有成员指针
为解决二进制兼容
所谓二进制兼容动态库，指的是一个在老版本库下运行的程序，在不经过编译的情况下，仍然能够在新的版本库下运行；
需要经过编译才能在新版本下运行，而不需要修改该程序源代码，我们就说该动态库是源代码兼容的;

#### 9.qt模型
答：Qt中的View主要有三种QListView，QTreeView, QTabelView
而对应的Model是：QStringListModel, QAbstractItemModel , QStandardItemModel。
抽象 标准



#### 问：对Qt元对象系统了解吧？
        
答：了解。Qt对标准的C++进行了扩展，如信号槽、对象属性等。Qt的元对象编译系统MOC是一个预处理器，
当Qt读取源文件时检测到类中包含有Q_OBJECT宏时，则会创建一个新的文件（生成路径下的moc开头的文件），
将源码转换为C++编译器可以识别的代码写入moc开头的文件，然后C++编译器对其进行编译。当你的类需要使用Qt的扩展功能时，
如信号槽、对象属性等时，则必须使用MOC，反之如果你的类不使用这些功能的时候不要无畏的使用MOC增大源码体积。
使用MOC系统的方法：

        1. 继承QObject。

        2. 类中添加Q_OBJECT宏。

#### 问：对Qt的信号槽机制了解吧？
        
答：了解。信号和槽是用于对象之间的通信的，是Qt的核心。
为此Qt引入了一些关键字，他们是slots、signals、emit，这些都不是C++关键字，是Qt特有的，
这些关键字会被Qt的moc转换为标准的C++语句。信号槽支持线程间通信，connect函数的第五个参数可以指定信号槽的连接方式：

        
1. Qt::AutoConnection：信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection；如果不在同一线程，则默认  使用Qt::QueuedConnection。
       
 2. Qt::DirectConnection：信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号  
发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃。
       
 3. Qt::QueuedConnection：信号的发送者与信号的接收者不在同一线程中执行，
槽函数运行于信号的接收者线程，当发送信号后，  槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。
多线程环境下一般用这个。
        4. Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，
不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
        
5. Qt::UniqueConnection：可以通过按位或（|）与以上四个结合在一起使用。当设置此参数时，当某个信号和槽已经连接时，再进行重复的连接就会失败，
也就是避免了重复连接。


#### 问：Qt中的MVD了解吧？
        
答：了解。Qt的MVD包含三个部分Model（模型），View（视图），代理（Delegate）。
Model否则保存数据，View负责展示数据，Delegate负责Item样式绘制或处理输入。
这三部分通过信号槽来进行通信，当Model中数据发生变化时将会发送信号到View，在View中编辑数据时，
Delegate负责将编辑状态发送给Model层。基类分别为QAbstractItemModel、QAbstractItemView、QAbstractItemDelegate。
Qt中提供了默认实现的MVD类，如QTableWidget、QListWidget、QTreeWidget等。

#### 问：对QGraphicsView了解吧？

#### 问：对Qt的多线程了解吧？
        
答：了解。Qt的多线程的实现方式有如下四种：

        
1. QThread类，重写QThread类的run方法。

        优点：实现简单，可以用信号槽通信。

        
缺点：需要自己管理线程的创建释放，频繁地创建释放效率不高。所以适合常驻程序的线程使用。
另外因为QThread对象属于父线程，所以对象中的槽函数（如果有的话）其实会在父线程执行。

        
2. QThread类与MoveToThread，创建对象继承QObject，将对象移动到子线程对象。

        
优点：实现简单，使用于比较复杂的业务场景。

        缺点：只能通过信号槽的方式调用业务对象的接口。且不能给此对象指定父对象。

        
3. QThreadPool与QRunnable，继承QRunnable实现run方法完成业务类创建，由QThreadPool启动业务类。

        
优点：无需关注线程资源管理，不会频繁创建与释放线程。所以适用需要频繁创建销毁线程的业务场景。

        缺点：没啥缺点。

        
4. QtConcurrent::run()直接将任务丢进子线程执行。

        优点：调用简单，无需关注线程资源管理，不会频繁创建与释放线程。

        
缺点：没啥缺点。

#### 问：对Qt的事件传递了解吧？
https://www.cnblogs.com/xiaobingqianrui/p/9547924.html



#### 一、讲述Qt信号槽机制与优势与不足
优点： 
①类型安全。需要关联的信号槽的签名必须是等同的。
即信号的参数类型和参数个数同接受该信号的槽的参数类型和参数个数相同。若信号和槽签名不一致，编译器会报错。

          
②松散耦合。信号和槽机制减弱了Qt对象的耦合度。激发信号的Qt对象无需知道是那个对象的那个信号槽接收它发出的信号，
它只需在适当的时间发送适当的信号即可，而不需要关心是否被接受和那个对象接受了。
Qt就保证了适当的槽得到了调用，即使关联的对象在运行时被删除。程序也不会奔溃。

         
③灵活性。一个信号可以关联多个槽，或多个信号关联同一个槽。

不足：速度较慢。与回调函数相比，信号和槽机制运行速度比直接调用非虚函数慢10倍。

       
 原因：①需要定位接收信号的对象。②安全地遍历所有关联槽。③编组、解组传递参数。④多线程的时候，信号需要排队等待。
（然而，与创建对象的new操作及删除对象的delete操作相比，信号和槽的运行代价只是他们很少的一部分。
信号和槽机制导致的这点性能损耗，对实时应用程序是可以忽略的。）

#### 二、Qt信号和槽的本质是什么 
        回调函数。信号或是传递值，或是传递动作变化；槽函数响应信号或是接收值，或者根据动作变化来做出对应操作。

#### 三、描述QT中的文件流(QTextStream)和数据流(QDataStream)的区别
       
文件流(QTextStream)。操作轻量级数据（int,double,QString）数据写入文本件中以后以文本的方式呈现。

       
数据流(QDataStream)。通过数据流可以操作各种数据类型，包括对象，存储到文件中数据为二进制。

        
文件流，数据流都可以操作磁盘文件，也可以操作内存数据。通过流对象可以将对象打包到内存，进行数据的传输。


#### 四、描述QT的TCP通讯流程
服务端：（QTcpServer）
        ①创建QTcpServer对象

        
②监听list需要的参数是地址和端口号

        
③当有新的客户端连接成功回发送newConnect信号

        
④在newConnection信号槽函数中，调用nextPendingConnection函数获取新连接QTcpSocket对象

        
⑤连接QTcpSocket对象的readRead信号

        ⑥在readRead信号的槽函数使用read接收数据

        
⑦调用write成员函数发送数据

#### 客户端：（QTcpSocket）

        ①创建QTcpSocket对象

        ②当对象与Server连接成功时会发送connected 信号

       
 ③调用成员函数connectToHost连接服务器，需要的参数是地址和端口号

        
④connected信号的槽函数开启发送数据

        ⑤使用write发送数据，read接收数据

#### 五、 描述UDP 之 UdpSocket通讯
           
UDP（User Datagram Protocol即用户数据报协议）是一个轻量级的，不可靠的，面向数据报的无连接协议。
在网络质量令人十分不满意的环境下，UDP协议数据包丢失严重。
由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、
视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。
所以QQ这种对保密要求并不太高的聊天程序就是使用的UDP协议。

        
在Qt中提供了QUdpSocket 类来进行UDP数据报（datagrams）的发送和接收。Socket简单地说，就是一个IP地址加一个port端口  。

        
流程：①创建QUdpSocket套接字对象 ②如果需要接收数据，必须绑定端口 ③发送数据用writeDatagram，接收数据用 readDatagram 。

#### 六、多线程使用使用方法
        方法一：①创建一个类从QThread类派生②在子线程类中重写 run 函数, 
将处理操作写入该函数中 ③在主线程中创建子线程对象, 启动子线程, 调用start()函数

        
方法二：①将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数②在主线程中创建一QThread类对象 
③在主线程中创建一个业务类对象 ④将业务类对象移动到子线程中 ⑤在主线程中启动子线程 ⑥通过信号槽的方式, 
执行业务类中的业务处理函数

多线程使用注意事项: 
* 1. 业务对象, 构造的时候不能指定父对象 
* 2. 子线程中不能处理ui窗口(ui相关的类) 
* 
3. 子线程中只能处理一些数据相关的操作, 不能涉及窗口

#### 七、多线程下，信号槽分别在什么线程中执行，如何控制
        
可以通过connect的第五个参数进行控制信号槽执行时所在的线程

　　
connect有几种连接方式，直接连接和队列连接、自动连接

　　
直接连接（Qt::DirectConnection）：信号槽在信号发出者所在的线程中执行

　　
队列连接 (Qt::QueuedConnection)：信号在信号发出者所在的线程中执行，槽函数在信号接收者所在的线程中执行

　　
自动连接  (Qt::AutoConnection)：多线程时为队列连接函数，单线程时为直接连接函数。


#### 1.请介绍下 qt中QObject类是做什么的，有哪些功能?
很多人只知道和信号槽机制有关系

如果还能答出 父子树节点管理 基本就算及格。

若还能回答出 rtti 定时器 属性系统 等就算优秀

#### 2.接上个问题 请说下qt的父子树节点管理机制

#### 3.接上问，除了qt父子树管理机制能智能管理对象生命周期，还有哪些避免内存泄露的机制?

#### 4.大部分人能答出智能指针，就可以问下std::shared_ptr的实现机制。

#### 5.如能回答出 基于引用计数，计数为0则清零，则可以问下共享式指针的缺点是什么?



#### 6.如能说出 性能损失和循环引用，则可以问如何破解循环引用。会带出弱指针。

#### 7.接问题3 如果能答出内存池，则有必要问下内存池的实现机制和在内存池中分配对象的需要注意的事项? 很少有人能回答出显式调用构造和析构函数。

#### 8.设计模式相关请说下qt中都用到了哪些设计模式 如何能答出 观察者模式 不得分
如能回答出 单例 工厂 责任链 状态机 备忘录 享元 装饰器 等则可以问下哪里使用到了?  此类模式优缺点什么?
以上8个问题如果能完整回答4个以上 则说明c++基本功 面向对象分析设计和设计模式都掌握的不错。
