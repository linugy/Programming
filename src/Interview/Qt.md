## 目录
### 元对象系统
#### QObject
#### qmake
### 信号槽
#### 信号槽原理
#### 信号槽优缺点
#### 信号槽用法
#### 信号槽第五个参数
### 多线程
#### 多线程用法
#### 多线程同步
### 信号槽和多线程
### 事件传递
### Qt下TCP通信过程
### Qt下UDP通信过程
### MVD
### Qt翻译
### 其他
#### Qt中设计模式
#### Qt智能指针，与C++智能指针的区别
#### q指针和d指针，二进制兼容
#### 如何保证只打开一个exe
#### show() exec()区别

   
//================================================================================================================

1.qt中QObject类是做什么的，有哪些功能?
QObject是Qt实现元对象系统的基础，元对象系统是...

2.了解元对象系统吗？
元对象系统是Qt对标准的C++进行的扩展，提供了（1）信号槽机制（2）动态属性系统（3）运行时类型识别 （4）对象树 等功能，
为了使用原对象系统，需要（1）QObject类：作为使用元对象类的基类（2）Q_OBJECT宏：用于启动元对象系统（3）MOC（Meta-Object Compiler，元对象编译器）：为每个QObject子类提供必要的代码
moc工作流程：读取源文件检测到类中包含有Q_OBJECT宏时，则会创建一个moc开头的C++源文件，其中包含了类的元对象代码。这些产生的源文件包含进类的源文件中，一起进行编译。

2.1 信号槽机制(后面详细讲)

2.2 动态属性系统
QObject::setProperty()和QObject::property()通过名字来动态设置或者获取对象属性；

2.3 运行时类型识别
RTTI （Runtime Type Information，运行时类型信息），它提供了运行时确定对象类型的方法,
程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。

QObject::metaObject()函数可以返回一个类的元对象，它是QMetaObject类的对象；
QMetaObject::className()可以在运行时以字符串形式返回类名，而不需要C++编辑器原生的运行时类型信息（RTTI）的支持；

2.4 对象树
Qt中使用对象树（object tree）来管理所有的QObject类及其子类的对象。当创建一个QObject时，如果使用了其他的对象作为其父对象（parent），
那么这个QObject就会被添加到父对象的children()列表中，这样当父对象被销毁时，这个QObject也会被销毁。

2.5 Qt运行时类型识别 和 C++运行时类型信息
https://blog.csdn.net/songsong2017/article/details/103604885

2.6 qobject_cast 和 C++的cast
使用qobject_cast()函数来对QObject类进行动态类型转换，这个函数的功能类似于标准C++中的dynamic_cast()函数，但它不再需要RTTI的支持。

3.qmake,make,makefile
https://blog.csdn.net/lvdepeng123/article/details/79007988

//================================================================================================================

1.信号槽原理
https://blog.csdn.net/weixin_43327696/article/details/105819597
https://zhuanlan.zhihu.com/p/75126932
信号槽的实现原理
答:信号槽实际就是观察者模式,当某个事件发生之后,它就会发出一个信号(signal),
这个信号类似广播, 想要处理的信号和自己的一个函数(槽函数(slot))绑定处理这个信号
当信号发出时,被链接的槽函数会自动被回调;
信号和槽是qt特有的信息传回机制,是QT设计程序的重要基础,它可以让互不相干扰的对象建立一种联系;
槽本质是类的成员函数,其参数可以是任意类型。
和函数唯一区别是：槽可以与信号连接在一起,每当和槽连接的信号被发射的时候,就会调用这个槽。

1.1 信号与槽、和事件的区别
1.2 自定义结构体到信号与槽要注意什么
1.3 怎么自己实现 Qt 的信号与槽？
1.4 信号与槽的底层原理；信号与槽怎么做到性能优化

2.信号槽优缺点
优点：
①类型安全。需要关联的信号槽的签名必须是等同的。
即信号的参数类型和参数个数同接受该信号的槽的参数类型和参数个数相同。若信号和槽签名不一致，编译器会报错。

          
②松散耦合。信号和槽机制减弱了Qt对象的耦合度。激发信号的Qt对象无需知道是那个对象的那个信号槽接收它发出的信号，
它只需在适当的时间发送适当的信号即可，而不需要关心是否被接受和那个对象接受了。
Qt就保证了适当的槽得到了调用，即使关联的对象在运行时被删除。程序也不会奔溃。

         
③灵活性。一个信号可以关联多个槽，或多个信号关联同一个槽。


不足：速度较慢。与回调函数相比，信号和槽机制运行速度比直接调用非虚函数慢10倍。

       
 原因：①需要定位接收信号的对象。②安全地遍历所有关联槽。③编组、解组传递参数。④多线程的时候，信号需要排队等待。
（然而，与创建对象的new操作及删除对象的delete操作相比，信号和槽的运行代价只是他们很少的一部分。
信号和槽机制导致的这点性能损耗，对实时应用程序是可以忽略的。）

#### 3.信号槽优缺点
优点：
（1）低耦合：发送方不用管接收方是谁，只需要发送信号即可。同理，接收方也不用知道发送方是谁，只要信号到了就可以执行槽函数。
（2）类型安全：信号的参数类型和个数与接收方的一致。
缺点：
（1）效率低：需要找接受信号的对象。

优缺点：
a QT信号槽机制的引用精简了程序员的代码量;
b QT的信号可以对应多个槽（但他们的调用顺序是随机），也可以多个槽映射一个信号;
c QT的信号槽的建立和解除绑定十分自由;
d信号槽同真正的回调函数比起来时间的耗损还是很大的，所有在嵌入式实时系统中应当慎用;
e信号槽的参数限定很多例如不能携带模板类参数，不能出现宏定义等等;


2.1信号与槽与函数指针的比较


3.信号槽用法
连接方式：
（1）使用SIGNAL和SLOT宏，此时信号的参数不能比槽的参数少，举例：
```
  connect(sender, SIGNAL(destroyed(QObject*)), this, SLOT(objectDestroyed(Qbject*)));
  connect(sender, SIGNAL(destroyed(QObject*)), this, SLOT(objectDestroyed()));
  connect(sender, SIGNAL(destroyed()), this, SLOT(objectDestroyed()));
```
（2）使用函数指针：
connect(sender, &QObject::destroyed, this, &MyObject::objectDestroyed);
（3）使用lambda：
connect(sender, &QObject::destroyed, [=](){ this->m_objects.remove(sender); });

3.1 lambda


4.信号槽第五个参数

1. Qt::AutoConnection：信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection；如果不在同一线程，则默认  使用Qt::QueuedConnection。
       
 2. Qt::DirectConnection：信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号  
发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃。
       
 3. Qt::QueuedConnection：信号的发送者与信号的接收者不在同一线程中执行，
槽函数运行于信号的接收者线程，当发送信号后，  槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。
多线程环境下一般用这个。
        4. Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，
不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
        
5. Qt::UniqueConnection：可以通过按位或（|）与以上四个结合在一起使用。当设置此参数时，当某个信号和槽已经连接时，再进行重复的连接就会失败，
也就是避免了重复连接。



//================================================================================================================

1.多线程用法

1.Qt提供了几种同步方式
多线程（创建线程的2种方式，线程同步的5种方式，防止界面冻结的2种方式）
##### （1）：①创建一个类从QThread类派生②在子线程类中重写 run 函数, 将处理操作写入该函数中 ③在主线程中创建子线程对象, 启动子线程, 调用start()函数
优点：实现简单，可以用信号槽通信。
缺点：需要自己管理线程的创建释放，频繁地创建释放效率不高。所以适合常驻程序的线程使用。另外因为QThread对象属于父线程，所以对象中的槽函数（如果有的话）其实会在父线程执行。
        
##### （2）：①将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数②在主线程中创建一QThread类对象 ③在主线程中创建一个业务类对象 ④将业务类对象移动到子线程中 
⑤在主线程中启动子线程 ⑥通过信号槽的方式, 执行业务类中的业务处理函数
优点：实现简单，使用于比较复杂的业务场景。
缺点：只能通过信号槽的方式调用业务对象的接口。且不能给此对象指定父对象。

##### （3）QThreadPool与QRunnable，继承QRunnable实现run方法完成业务类创建，由QThreadPool启动业务类。
优点：无需关注线程资源管理，不会频繁创建与释放线程。所以适用需要频繁创建销毁线程的业务场景。
        
##### （4）QtConcurrent::run()直接将任务丢进子线程执行。
优点：调用简单，无需关注线程资源管理，不会频繁创建与释放线程。

##### 多线程使用注意事项:（1）业务对象, 构造的时候不能指定父对象；（2）子线程中只能处理一些数据相关的操作, 不能涉及ui窗口(ui相关的类)


2.多线程同步

3.防止界面冻结的方法：

//================================================================================================================

1.信号槽和多线程
        
可以通过connect的第五个参数进行控制信号槽执行时所在的线程
　　
connect有几种连接方式，直接连接和队列连接、自动连接
　　
直接连接（Qt::DirectConnection）：信号槽在信号发出者所在的线程中执行
　　
队列连接 (Qt::QueuedConnection)：信号在信号发出者所在的线程中执行，槽函数在信号接收者所在的线程中执行

自动连接  (Qt::AutoConnection)：多线程时为队列连接函数，单线程时为直接连接函数。

//================================================================================================================

https://blog.csdn.net/luolaihua2018/article/details/110797592

1.事件传递
15.qt 的消息传递机制
17.Qt的事件过滤器 （事件的传递是由子类往父类上传的）
事件系统（自定义事件处理函数3种方式）
https://www.cnblogs.com/xiaobingqianrui/p/9547924.html

2.事件循环
Qt的主事件循环能够从事件队列中获取本地窗口系统事件，然后判断事件类型，并将事件分发给特定的接收对象。
主事件循环通过调用QCoreApplication::exec()启动，随着QCoreApplication::exit()结束，本地的事件循环可用利用QEventLoop构建。

//================================================================================================================

1.Qt下TCP通信过程
服务端：（QTcpServer）
        ①创建QTcpServer对象

        
②监听list需要的参数是地址和端口号

        
③当有新的客户端连接成功回发送newConnect信号

        
④在newConnection信号槽函数中，调用nextPendingConnection函数获取新连接QTcpSocket对象

        
⑤连接QTcpSocket对象的readRead信号

        ⑥在readRead信号的槽函数使用read接收数据

        
⑦调用write成员函数发送数据

客户端：（QTcpSocket）

        ①创建QTcpSocket对象

        ②当对象与Server连接成功时会发送connected 信号

       
 ③调用成员函数connectToHost连接服务器，需要的参数是地址和端口号

        
④connected信号的槽函数开启发送数据

        ⑤使用write发送数据，read接收数据

//================================================================================================================

1.Qt下UDP通信过程
           
UDP（User Datagram Protocol即用户数据报协议）是一个轻量级的，不可靠的，面向数据报的无连接协议。
在网络质量令人十分不满意的环境下，UDP协议数据包丢失严重。
由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、
视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。
所以QQ这种对保密要求并不太高的聊天程序就是使用的UDP协议。

        
在Qt中提供了QUdpSocket 类来进行UDP数据报（datagrams）的发送和接收。Socket简单地说，就是一个IP地址加一个port端口  。

        
流程：①创建QUdpSocket套接字对象 ②如果需要接收数据，必须绑定端口 ③发送数据用writeDatagram，接收数据用 readDatagram 。

//================================================================================================================

1.Qt中的MVD
Qt的MVD包含三个部分Model（模型），View（视图），代理（Delegate）。
Model否则保存数据，View负责展示数据，Delegate负责Item样式绘制或处理输入。
这三部分通过信号槽来进行通信，当Model中数据发生变化时将会发送信号到View，在View中编辑数据时，
Delegate负责将编辑状态发送给Model层。基类分别为QAbstractItemModel、QAbstractItemView、QAbstractItemDelegate。
Qt中提供了默认实现的MVD类，如QTableWidget、QListWidget、QTreeWidget等。

//================================================================================================================

1.Qt翻译流程
https://blog.csdn.net/weibuu/article/details/108802258

//================================================================================================================

1.qt中都用到了哪些设计模式
（1）单例模式：qApp
（2）观察者模式：信号槽

//================================================================================================================

 Qt智能指针与C++智能指针的区别
https://blog.csdn.net/iriczhao/article/details/122117218
https://zhuanlan.zhihu.com/p/364014571?ivk_sa=1024320u

//================================================================================================================

#### 7.q、d指针为了解决什么问题？
为解决二进制兼容
所谓二进制兼容动态库，指的是一个在老版本库下运行的程序，在不经过编译的情况下，仍然能够在新的版本库下运行；
需要经过编译才能在新版本下运行，而不需要修改该程序源代码，我们就说该动态库是源代码兼容的;

//================================================================================================================

1.如何保证只打开一个exe
使用 系统信号量 QSystemSemaphore 与 共享内存 QSharedMemory
```
    QSystemSemaphore sema("JAMKey",1,QSystemSemaphore::Open);
    sema.acquire();//在临界区操作共享内存  SharedMemory
    QSharedMemory mem("SystemObject");//全局对象名
    if (!mem.create(1))//如果全局对象以存在则退出
    {
        sema.release();//如果是Unix系统，会自动释放。
        return 0;
    }
    sema.release();//临界区
```

//================================================================================================================

1.show() exec()区别

模式窗口：窗口会原地阻塞，只能操作该窗口，其余窗口不能再操作；只有关闭该窗口后，代码处才会获得返回值，阻塞停止，就可以操作其它界面了；

半模式窗口：窗口会原地伪阻塞，虽然也是只能操作该窗口，其余窗口不能再操作，但是代码会继续往下运行，所以说是伪阻塞；

非模式窗口：窗口不会阻塞，可以随意操作；

模式窗口：Dlg->exec();
半模式窗口： Dlg->setModal(true); Dlg->show();
非模式窗口：Dlg->show();

//================================================================================================================


知识点：http://shouce.jb51.net/qt-beginning/48.html

面试题：https://www.zhihu.com/question/451327108


#### 1.请介绍下 qt中QObject类是做什么的，有哪些功能?
很多人只知道和信号槽机制有关系
如果还能答出 父子树节点管理 基本就算及格。
若还能回答出 rtti 定时器 属性系统 等就算优秀
#### 2.接上个问题 请说下qt的父子树节点管理机制
#### 3.接上问，除了qt父子树管理机制能智能管理对象生命周期，还有哪些避免内存泄露的机制?
#### 4.大部分人能答出智能指针，就可以问下std::shared_ptr的实现机制。
#### 5.如能回答出 基于引用计数，计数为0则清零，则可以问下共享式指针的缺点是什么?


#### 6.如能说出 性能损失和循环引用，则可以问如何破解循环引用。会带出弱指针。
#### 7.接问题3 如果能答出内存池，则有必要问下内存池的实现机制和在内存池中分配对象的需要注意的事项? 很少有人能回答出显式调用构造和析构函数。
#### 8.设计模式相关请说下qt中都用到了哪些设计模式 如何能答出 观察者模式 不得分
如能回答出 单例 工厂 责任链 状态机 备忘录 享元 装饰器 等则可以问下哪里使用到了?  此类模式优缺点什么?
以上8个问题如果能完整回答4个以上 则说明c++基本功 面向对象分析设计和设计模式都掌握的不错。