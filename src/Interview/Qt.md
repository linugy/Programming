## 目录
### 元对象系统
#### QObject
#### qmake
### 信号槽
#### 信号槽原理
#### 信号槽优缺点
#### 信号槽用法
#### 信号槽第五个参数
### 多线程
#### 多线程槽用法
#### 多线程同步
### 信号槽和多线程
### 事件传递
### Qt下TCP通信过程
### Qt下UDP通信过程
### QSS
### 国际化
### Qt中设计模式
### 插件管理器
### MVD
### QGraphicsView
### QT中的文件流(QTextStream)和数据流(QDataStream)
### q指针和d指针
### Qt智能指针
#### 与C++智能指针的区别
### 其他
#### 如何保证只打开一个exe
#### QString和string的区别
#### show() exec()区别
#### 用QT实现一个三角形的按钮，会如何实现?

 （写个例子）     


#### 1.多线程
2.Qt中，说一下创建线程方式
1.Qt提供了几种同步方式
多线程（创建线程的2种方式，线程同步的5种方式，防止界面冻结的2种方式）
##### （1）：①创建一个类从QThread类派生②在子线程类中重写 run 函数, 将处理操作写入该函数中 ③在主线程中创建子线程对象, 启动子线程, 调用start()函数
优点：实现简单，可以用信号槽通信。
缺点：需要自己管理线程的创建释放，频繁地创建释放效率不高。所以适合常驻程序的线程使用。另外因为QThread对象属于父线程，所以对象中的槽函数（如果有的话）其实会在父线程执行。
        
##### （2）：①将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数②在主线程中创建一QThread类对象 ③在主线程中创建一个业务类对象 ④将业务类对象移动到子线程中 
⑤在主线程中启动子线程 ⑥通过信号槽的方式, 执行业务类中的业务处理函数
优点：实现简单，使用于比较复杂的业务场景。
缺点：只能通过信号槽的方式调用业务对象的接口。且不能给此对象指定父对象。

##### （3）QThreadPool与QRunnable，继承QRunnable实现run方法完成业务类创建，由QThreadPool启动业务类。
优点：无需关注线程资源管理，不会频繁创建与释放线程。所以适用需要频繁创建销毁线程的业务场景。
        
##### （4）QtConcurrent::run()直接将任务丢进子线程执行。
优点：调用简单，无需关注线程资源管理，不会频繁创建与释放线程。

##### 多线程使用注意事项:（1）业务对象, 构造的时候不能指定父对象；（2）子线程中只能处理一些数据相关的操作, 不能涉及ui窗口(ui相关的类)

#### 2.信号和槽
6.信号槽第五个参数：
5.信号槽连接有几种方式？直接连接是怎么执行的？
14.信号槽的实现原理
16.信号与槽与函数指针的比较
怎么自己实现 Qt 的信号与槽？
信号与槽、和事件的区别
自定义结构体到信号与槽要注意什么
信号与槽的底层原理；信号与槽怎么做到性能优化
https://zhuanlan.zhihu.com/p/75126932
https://blog.csdn.net/weixin_43327696/article/details/105819597
回调函数。信号或是传递值，或是传递动作变化；槽函数响应信号或是接收值，或者根据动作变化来做出对应操作。

#### 2.qt信号槽是什么？
答:信号槽实际就是观察者模式,当某个事件发生之后,它就会发出一个信号(signal),
这个信号类似广播, 想要处理的信号和自己的一个函数(槽函数(slot))绑定处理这个信号
当信号发出时,被链接的槽函数会自动被回调;
信号和槽是qt特有的信息传回机制,是QT设计程序的重要基础,它可以让互不相干扰的对象建立一种联系;
槽本质是类的成员函数,其参数可以是任意类型。
和函数唯一区别是：槽可以与信号连接在一起,每当和槽连接的信号被发射的时候,就会调用这个槽。
优缺点：
a QT信号槽机制的引用精简了程序员的代码量;
b QT的信号可以对应多个槽（但他们的调用顺序是随机），也可以多个槽映射一个信号;
c QT的信号槽的建立和解除绑定十分自由;
d信号槽同真正的回调函数比起来时间的耗损还是很大的，所有在嵌入式实时系统中应当慎用;
e信号槽的参数限定很多例如不能携带模板类参数，不能出现宏定义等等;

#### 3.讲述Qt信号槽机制与优势与不足
优点：
①类型安全。需要关联的信号槽的签名必须是等同的。
即信号的参数类型和参数个数同接受该信号的槽的参数类型和参数个数相同。若信号和槽签名不一致，编译器会报错。

          
②松散耦合。信号和槽机制减弱了Qt对象的耦合度。激发信号的Qt对象无需知道是那个对象的那个信号槽接收它发出的信号，
它只需在适当的时间发送适当的信号即可，而不需要关心是否被接受和那个对象接受了。
Qt就保证了适当的槽得到了调用，即使关联的对象在运行时被删除。程序也不会奔溃。

         
③灵活性。一个信号可以关联多个槽，或多个信号关联同一个槽。


不足：速度较慢。与回调函数相比，信号和槽机制运行速度比直接调用非虚函数慢10倍。

       
 原因：①需要定位接收信号的对象。②安全地遍历所有关联槽。③编组、解组传递参数。④多线程的时候，信号需要排队等待。
（然而，与创建对象的new操作及删除对象的delete操作相比，信号和槽的运行代价只是他们很少的一部分。
信号和槽机制导致的这点性能损耗，对实时应用程序是可以忽略的。）

#### 3.信号槽优缺点
优点：
（1）低耦合：发送方不用管接收方是谁，只需要发送信号即可。同理，接收方也不用知道发送方是谁，只要信号到了就可以执行槽函数。
（2）类型安全：信号的参数类型和个数与接收方的一致。
缺点：
（1）效率低：需要找接受信号的对象。

#### 4.问：对Qt的信号槽机制了解吧？
        
答：了解。信号和槽是用于对象之间的通信的，是Qt的核心。
为此Qt引入了一些关键字，他们是slots、signals、emit，这些都不是C++关键字，是Qt特有的，
这些关键字会被Qt的moc转换为标准的C++语句。信号槽支持线程间通信，connect函数的第五个参数可以指定信号槽的连接方式：

        
1. Qt::AutoConnection：信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection；如果不在同一线程，则默认  使用Qt::QueuedConnection。
       
 2. Qt::DirectConnection：信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号  
发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃。
       
 3. Qt::QueuedConnection：信号的发送者与信号的接收者不在同一线程中执行，
槽函数运行于信号的接收者线程，当发送信号后，  槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。
多线程环境下一般用这个。
        4. Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，
不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。
        
5. Qt::UniqueConnection：可以通过按位或（|）与以上四个结合在一起使用。当设置此参数时，当某个信号和槽已经连接时，再进行重复的连接就会失败，
也就是避免了重复连接。

#### 5.信号槽的四种写法和五种连接方式？
connect(信号发出者，信号，信号接收者，槽，连接方式(隐藏默认自动连接))//五个参数
四种写法：
1.用宏：
connect(this,SIGNAL(clicked()),this,SLOT(colse())); //连接方式(隐藏默认自动连接))
2.用函数指针： connect(this,&mainwindow::my_signal,this,&mainwindow::my_slot);
3.用重载函数指针Qoverload
connect(this,Qoverload<参数>::of(&mainwindow::my_signal),this,Qoverload<参数>::of(&mainwindow::my_slot));
4.lambda表达式(匿名函数) 匿名函数代替槽
connect(this,&mainwindow::my_signal,this,[=]{qDebug()<<100;});
连接方式：自动连接(默认连接方式)
直接连接(用于单线程,自动匹配)
队列(用于多线程也可用于单线程,自动匹配)
阻塞队列(跨线程,多线程)
唯一连接(跨线程,多线程)





#### 3、多线程与信号槽
        
可以通过connect的第五个参数进行控制信号槽执行时所在的线程
　　
connect有几种连接方式，直接连接和队列连接、自动连接
　　
直接连接（Qt::DirectConnection）：信号槽在信号发出者所在的线程中执行
　　
队列连接 (Qt::QueuedConnection)：信号在信号发出者所在的线程中执行，槽函数在信号接收者所在的线程中执行

自动连接  (Qt::AutoConnection)：多线程时为队列连接函数，单线程时为直接连接函数。






#### 4.问：元对象系统
        
答：了解。Qt对标准的C++进行了扩展，如信号槽、对象属性等。Qt的元对象编译系统MOC是一个预处理器，
当Qt读取源文件时检测到类中包含有Q_OBJECT宏时，则会创建一个新的文件（生成路径下的moc开头的文件），
将源码转换为C++编译器可以识别的代码写入moc开头的文件，然后C++编译器对其进行编译。当你的类需要使用Qt的扩展功能时，
如信号槽、对象属性等时，则必须使用MOC，反之如果你的类不使用这些功能的时候不要无畏的使用MOC增大源码体积。
使用MOC系统的方法：

        1. 继承QObject。

        2. 类中添加Q_OBJECT宏。


#### 5.事件传递
15.qt 的消息传递机制
17.Qt的事件过滤器 （事件的传递是由子类往父类上传的）
事件系统（自定义事件处理函数3种方式）
https://www.cnblogs.com/xiaobingqianrui/p/9547924.html

#### 6.事件循环
Qt的主事件循环能够从事件队列中获取本地窗口系统事件，然后判断事件类型，并将事件分发给特定的接收对象。
主事件循环通过调用QCoreApplication::exec()启动，随着QCoreApplication::exit()结束，本地的事件循环可用利用QEventLoop构建。

#### 7.q、d指针干什么用的？为了解决什么问题？
答：q子类获取父类私有成员指针
d在父类获取子类私有成员指针
为解决二进制兼容
所谓二进制兼容动态库，指的是一个在老版本库下运行的程序，在不经过编译的情况下，仍然能够在新的版本库下运行；
需要经过编译才能在新版本下运行，而不需要修改该程序源代码，我们就说该动态库是源代码兼容的;


#### 8、描述QT的TCP通讯流程
7.Qt下TCP通信过程
8.Qt下UDP通信过程
服务端：（QTcpServer）
        ①创建QTcpServer对象

        
②监听list需要的参数是地址和端口号

        
③当有新的客户端连接成功回发送newConnect信号

        
④在newConnection信号槽函数中，调用nextPendingConnection函数获取新连接QTcpSocket对象

        
⑤连接QTcpSocket对象的readRead信号

        ⑥在readRead信号的槽函数使用read接收数据

        
⑦调用write成员函数发送数据

客户端：（QTcpSocket）

        ①创建QTcpSocket对象

        ②当对象与Server连接成功时会发送connected 信号

       
 ③调用成员函数connectToHost连接服务器，需要的参数是地址和端口号

        
④connected信号的槽函数开启发送数据

        ⑤使用write发送数据，read接收数据

#### 9、 描述UDP 之 UdpSocket通讯
           
UDP（User Datagram Protocol即用户数据报协议）是一个轻量级的，不可靠的，面向数据报的无连接协议。
在网络质量令人十分不满意的环境下，UDP协议数据包丢失严重。
由于UDP的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、
视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。
所以QQ这种对保密要求并不太高的聊天程序就是使用的UDP协议。

        
在Qt中提供了QUdpSocket 类来进行UDP数据报（datagrams）的发送和接收。Socket简单地说，就是一个IP地址加一个port端口  。

        
流程：①创建QUdpSocket套接字对象 ②如果需要接收数据，必须绑定端口 ③发送数据用writeDatagram，接收数据用 readDatagram 。


#### 10：对QGraphicsView了解吧？



#### 11、描述QT中的文件流(QTextStream)和数据流(QDataStream)的区别
       
文件流(QTextStream)。操作轻量级数据（int,double,QString）数据写入文本件中以后以文本的方式呈现。

       
数据流(QDataStream)。通过数据流可以操作各种数据类型，包括对象，存储到文件中数据为二进制。

        
文件流，数据流都可以操作磁盘文件，也可以操作内存数据。通过流对象可以将对象打包到内存，进行数据的传输。


#### 12.qt模型
答：Qt中的View主要有三种QListView，QTreeView, QTabelView
而对应的Model是：QStringListModel, QAbstractItemModel , QStandardItemModel。
抽象 标准


#### 14：Qt中的MVD了解吧？
        
答：了解。Qt的MVD包含三个部分Model（模型），View（视图），代理（Delegate）。
Model否则保存数据，View负责展示数据，Delegate负责Item样式绘制或处理输入。
这三部分通过信号槽来进行通信，当Model中数据发生变化时将会发送信号到View，在View中编辑数据时，
Delegate负责将编辑状态发送给Model层。基类分别为QAbstractItemModel、QAbstractItemView、QAbstractItemDelegate。
Qt中提供了默认实现的MVD类，如QTableWidget、QListWidget、QTreeWidget等。

### 13.插件管理器
https://blog.csdn.net/kenfan1647/category_9967854.html

### 16.插件之间通信
https://blog.csdn.net/kenfan1647/category_9967854.html

8.https://blog.csdn.net/xpg4321/article/details/101278293


1.qt中都用到了哪些设计模式
1.单例模式：qApp
2.观察者模式：信号槽

18.为什么 new QWidget 不需要 delete
https://zhuanlan.zhihu.com/p/476682300
http://shouce.jb51.net/qt-beginning/48.html

#### show() exec()区别
模式窗口：窗口会原地阻塞，只能操作该窗口，其余窗口不能再操作；只有关闭该窗口后，代码处才会获得返回值，阻塞停止，就可以操作其它界面了；

半模式窗口：窗口会原地伪阻塞，虽然也是只能操作该窗口，其余窗口不能再操作，但是代码会继续往下运行，所以说是伪阻塞；

非模式窗口：窗口不会阻塞，可以随意操作；

模式窗口：Dlg->exec();
半模式窗口： Dlg->setModal(true); Dlg->show();
非模式窗口：Dlg->show();


#### 如何保证只打开一个exe（使用 系统信号量 QSystemSemaphore 与 共享内存 QSharedMemory）
    QSystemSemaphore sema("JAMKey",1,QSystemSemaphore::Open);
    sema.acquire();//在临界区操作共享内存  SharedMemory
    QSharedMemory mem("SystemObject");//全局对象名
    if (!mem.create(1))//如果全局对象以存在则退出
    {
        sema.release();//如果是Unix系统，会自动释放。
        return 0;
    }
    sema.release();//临界区

#### QString和string的区别
https://blog.csdn.net/qq_32733991/article/details/83748904

#### 1.请介绍下 qt中QObject类是做什么的，有哪些功能?
很多人只知道和信号槽机制有关系
如果还能答出 父子树节点管理 基本就算及格。
若还能回答出 rtti 定时器 属性系统 等就算优秀
#### 2.接上个问题 请说下qt的父子树节点管理机制
#### 3.接上问，除了qt父子树管理机制能智能管理对象生命周期，还有哪些避免内存泄露的机制?
#### 4.大部分人能答出智能指针，就可以问下std::shared_ptr的实现机制。
#### 5.如能回答出 基于引用计数，计数为0则清零，则可以问下共享式指针的缺点是什么?


#### 6.如能说出 性能损失和循环引用，则可以问如何破解循环引用。会带出弱指针。
#### 7.接问题3 如果能答出内存池，则有必要问下内存池的实现机制和在内存池中分配对象的需要注意的事项? 很少有人能回答出显式调用构造和析构函数。
#### 8.设计模式相关请说下qt中都用到了哪些设计模式 如何能答出 观察者模式 不得分
如能回答出 单例 工厂 责任链 状态机 备忘录 享元 装饰器 等则可以问下哪里使用到了?  此类模式优缺点什么?
以上8个问题如果能完整回答4个以上 则说明c++基本功 面向对象分析设计和设计模式都掌握的不错。