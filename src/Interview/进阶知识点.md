### 1.线程和进程
#### （1）进程是资源分配的独立单位；线程是资源调度的独立单位
#### （2）一个进程由多个线程组成；
#### （3）进程之间切换开销大；线程之间切换的开销小

### 2.线程同步和互斥
暂时只看Qt的线程同步

### 3.动态库和静态库区别
#### 静态库：（.a或.lib），所有相关的文件和库被链接到一个可执行文件。
#### 动态库：（.so或.dll），在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。

### 4.程序编译过程
####  预编译：处理#include，#define等预编译指令
####  编译：进行词法分析、预防分析等过程
####  汇编：将汇编指令翻译成机器指令，生成目标文件
####  链接：将目标文件链接在一起生成可执行文件

### 5.实现strcpy函数
https://blog.csdn.net/hhhuang1991/article/details/79955057
```
char *strcpy(char *str1, const char *str2)
{
    if (str1 == NULL || str2 == NULL) {
        return NULL;
    }

    while (*str2 != '\0') {
        *str1 = *str2;
        str1++;
        str2++;
    }
    str1 = '\0';
    return str1;
}
```

### 6.实现strcmp函数
https://blog.csdn.net/wgenek/article/details/7257435
https://www.cnblogs.com/litifeng/p/7465173.html
```
int strcmp(const char *str1, const char *str2)
{
    while ((*str1) && *str1 == *str2) {
        str1++;
        str2++;
    }

    if (*str1 > *str2) {
        return 1;
    } else if (*str1 < *str2) {
        return -1;
    } else {
        return 0;
    }
}
```

### 7.实现memcpy函数
https://www.cnblogs.com/chuanfengzhang/p/8447251.html
https://blog.csdn.net/goodwillyang/article/details/45559925
https://www.cnblogs.com/liangyc/p/11628723.html

```
void *memcpy(void *dest, const void *src, int n)
{
    if (dest == NULL || src == NULL || n <= 0) {
        return NULL;
    }

    char *pDest = (char *)dest;
    char *pSrc = (char *)src;

    if (pDest > pSrc && pDest < pSrc + n) {
        pDest = pDest + n - 1;
        pSrc = pSrc + n - 1;
        while (n--) {
            *pDest-- = *pSrc--;
        }
    } else {
        while (n--) {
            *pDest++ = *pSrc++;
        }
    }
    return dest;
}
```

### 8.二分查找
https://www.cnblogs.com/kyoner/p/11080078.html
https://www.cnblogs.com/luoxn28/p/5767571.html
```
int binarySearch(int arr[], int key)
{
    int low = 0;
    int high = arr.length - 1;

    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == key) {
            return mid;
        } else if (arr[mid] > key) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
```

### 8.堆栈溢出原因
（1）递归调用
（2）申请内存后没有释放

### 9.信号槽优缺点
#### 优点：
（1）低耦合：发送方不用管接收方是谁，只需要发送信号即可。同理，接收方也不用知道发送方是谁，只要信号到了就可以执行槽函数。
（2）类型安全：信号的参数类型和个数与接收方的一致。
#### 缺点：
（1）效率低：需要找接受信号的对象。

### 10.指针和引用的区别
（1）指针是一个变量，存放的是地址；引用是变量的别名
（2）引用必须初始化，指针可以在任意时间初始化
（3）有const指针，但是没有const引用

### 11.二叉树的遍历
#### 先序遍历：父节点-左孩子-右孩子
#### 中序遍历：左孩子-父节点-右孩子
#### 后续遍历：左孩子-右孩子-父节点
#### 层次遍历：从上到下，从左到右

### 12.变量的声明和定义有什么区别
#### 声明：不分配内存空间；可以多次声明；
#### 定义：分配内存空间；只能定义一次；

### 13.C++智能指针
#### shared_ptr：允许多个指针指向同一个对象。引用计数。
#### unique_ptr
#### weak_ptr

### 14.信号槽的实现原理
观察者模式

### 15.char str[] 和 char *str的相等比较和内存对齐大小

### 16.strstr函数

### 17.C++实现排序函数

### 18.计算十六进制数中1的个数

### 19.在哪里用到过多态
槽函数里使用sender，返回一个QObject

### 20.链表长度n，在i（1到n+1）位置插入数据，需要移动多少次
n-i+1

### 21.Map和Hash的底层实现

### 22.插件管理器
https://blog.csdn.net/kenfan1647/category_9967854.html

### 23.插件之间通信
https://blog.csdn.net/kenfan1647/category_9967854.html